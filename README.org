#+title: Advent of Code 2021
#+author: @hiepph

* Overview
  It's that time of the year again! Head for [[https://adventofcode.com/2021][Advent of Code 2021]].
  This year's theme is also Clojure.

* Write-up
** Day 4
   It's important to break down a task into sub-problems and solve each with a function.
   There is a reason it's called functional programming.

   First is the function to check if a board's condition is enough to win.
   Additional tranpose functionality is added to deal with the 2d matrix.
   #+begin_src clojure
(defn transpose [m]
  (apply mapv vector m))

(defn win?
  [board]
  (or
   (some true? (map #(every? true? %) board))
   (some true? (map #(every? true? %) (transpose board)))))
   #+end_src

   My first thought when approaching the problem was:
   #+begin_src clojure
(for [guess guesses]
  (for [board boards]
    (for [row board]
      (for [num row]
        ;; ...
        ))))
   #+end_src
   As you see I was trying to code into a triangular shape.
   Inside nested loop I was trying to check winning condition and complicated modification logic.
   To break the loop when the winning condition is met is also a big problem.
   I even thought of modifying the variable ~boards~ by ~assoc-in~. That's not an idiom of functional programming.
   This is a sign to break down the problems. I have to make the code as *flat* as possible.

   So I divided into sub-problems to deal with individual board, and then individual row:
   #+begin_src clojure
(defn mark-row
  "Mark a row with all the numbers equal the guess to true."
  [row guess]
  (map
   #(if (= % guess) true %)
   row))

(defn mark-board
  "Mark a board with all the numbers equal the guess to true."
  [board guess]
  (map
   #(mark-row % guess)
   board))
   #+end_src

   To solve early break problem I use loop:
   #+begin_src clojure
(loop [boards boards
         guesses guesses]
    (let [guess (first guesses)
          boards (map #(mark-board % guess) boards)
          win-board (some #(if (win? %) %) boards)]
      (if win-board
        ;; break here
        [win-board guess]
        (recur boards (rest guesses)))))
   #+end_src

** Day 5
   Generate a 2d diagram:
   #+begin_src clojure
(def diagram
  (into [] (repeat n
                   (into [] (repeat n 0)))))
   #+end_src
   It's necessary to use ~(into [] ...)~ since I can only modify elements in a vector using ~update-in~.

   Since x1 can be larger than x2 (so does y1 and y2) so I wrote a helper to generate a range which does not care about the direction:
   #+begin_src clojure
(defn gen-range
  "Helper to generate a range, either from smaller number to larger number
  or from larger number to smaller number."
  [a b]
  (if (< a b)
    (range a (inc b))
    (range a (dec b) -1)))
   #+end_src

   Again, I broke down the problem into a sub-problem of marking a diagram with a list of coordinates ~[x y]~:
   #+begin_src clojure
(defn mark-diagram-with-coords
  "Mark diagram from a list of coords [x y]"
  [diagram coord]
  (reduce
   (fn [res [x y]]
     (update-in res [y x] inc))
   diagram
   coord))
   #+end_src

   So I can concentrate on the logic of making the slice of coordinates:
   #+begin_src clojure
(defn mark-diagram
  "Mark diagram derived from a couple of coord [x1 y1 x2 y2]"
  [diagram couple-coord]
  (let [[x1 y1 x2 y2] couple-coord]
    (if (= y1 y2)
      ;; horizontally
      (mark-diagram-with-coords
       diagram
       (map #(vector % y1) (gen-range x1 x2)))

      ;; vertically
      (mark-diagram-with-coords
       diagram
       (map #(vector x1 %) (gen-range y1 y2))))))
   #+end_src

   Part 2 is just a piece of cake by building up from the solution of part 1:
   #+begin_src clojure
(defn mark-diagram-2
  [diagram couple-coord]
  (let [[x1 y1 x2 y2] couple-coord]
    (if (or (= x1 x2)
            (= y1 y2))
      (mark-diagram diagram couple-coord)
      ;; diagonally
      (mark-diagram-with-coords
       diagram
       (zipmap (gen-range x1 x2) (gen-range y1 y2))))))
   #+end_src

   In part 1, by using loop I can filter from the start:
   #+begin_src clojure
(loop [diagram diagram
         couple-coords (filter (fn [couple-coord]
                          (let [[x1 y1 x2 y2] couple-coord]
                            (or (= x1 x2)
                                (= y1 y2))))
                        couple-coords)]
    # ...
)
   #+end_src
